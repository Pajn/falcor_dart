library falcor_dart.strip_path;

import 'package:falcor_dart/src/utils.dart';
import 'package:falcor_dart/src/operations/strip/strip.dart';

/**
 * Takes in the matched path and virtual path and creates the
 * set of paths that represent the virtualPath being stripped
 * from the matchedPath.
 *
 * @example
 * Terms:
 * * Relative Complement: Of sets A and B the relative complement of A in B is
 * the parts of B that A do not contain.  In our example its virtualPath (A) in
 * matchedPath (B).
 *
 * Example:
 * matchedInput = [[A, D], [B, E], [C, F]]
 * virtualIntput = [A, Keys, C]
 *
 * This will produce 2 arrays from the matched operation.
 * [
 *   [D, [B, E], [C, F]],
 *   [A, [B, E], [F]]
 * ]
 *
 *
 * All the complexity of this function is hidden away in strip and its inner
 * stripping functions.
 * @param {PathSet} matchedPath
 * @param {PathSet} virtualPath
 */
List stripPath(List matchedPath, List virtualPath) {
  var relativeComplement = [];
  var exactMatch = [];
  var current = [];

  // Always use virtual path because it can be shorter.
  for (var i = 0, len = virtualPath.length; i < len; ++i) {
    var matchedAtom = matchedPath[i];
    var virtualAtom = virtualPath[i];
    var stripResults = strip(matchedAtom, virtualAtom);
    var innerMatch = stripResults[0];
    var innerComplement = stripResults[1];
    var hasComplement = innerComplement.length > 0;

    // using the algorithm partially described above we need to split and
    // combine output depending on what comes out of the split function.
    // 1.  If there is no relative complement do no copying / slicing.
    // 2.  If there is both the catAndslice.

    if (hasComplement) {
      print('DANGER!!!!!!!!!!!!!!!!');
      print('hasComplement may be wierd');
      var flattendIC =
          innerComplement.length == 1 ? innerComplement[0] : innerComplement;
      current[i] = flattendIC;
      relativeComplement.add(catAndSlice(current, matchedPath, i + 1));
    }

  // The exact match needs to be produced for calling function.
    exactMatch.add(innerMatch);
    current.add(innerMatch);
  }

  return [exactMatch, relativeComplement];
}
